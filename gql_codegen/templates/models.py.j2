"""Generated GraphQL models.

All fields are Optional for maximum flexibility in test automation.
The GraphQL API will validate required fields at runtime.

IMPORTANT: Call ensure_models_rebuilt() before using models with forward references.
"""

from __future__ import annotations
from typing import Optional, List, Any, Union, TYPE_CHECKING
from pydantic import BaseModel, Field, ConfigDict
from ..scalars import *
from ..enums import *

{#- Collect modules needed for inheritance (runtime imports) #}
{%- set runtime_imports = {} %}
{%- for type in types %}
{%- for iface in type.full_interfaces if '.' in iface %}
{%- set module = iface.split('.')[0] %}
{%- if module not in runtime_imports %}
{%- set _ = runtime_imports.update({module: true}) %}
{%- endif %}
{%- endfor %}
{%- endfor %}

{#- Runtime imports for inheritance #}
{%- if runtime_imports %}
{%- for module in runtime_imports.keys() %}
from . import {{ module }}
{%- endfor %}
{%- endif %}

if TYPE_CHECKING:
{%- set type_check_imports = {} %}
{%- for dep_file, dep_types in external_imports.items() if dep_file not in runtime_imports %}
{%- set _ = type_check_imports.update({dep_file: dep_types}) %}
{%- endfor %}
{%- if type_check_imports %}
{%- for dep_file, dep_types in type_check_imports.items() %}
    from . import {{ dep_file }}
{%- endfor %}
{%- else %}
    pass
{%- endif %}


{# Macro for field name with reserved word handling #}
{# Include Python keywords AND builtins that would cause collisions #}
{%- set PYTHON_RESERVED = [
    'False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await',
    'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except',
    'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is',
    'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try',
    'while', 'with', 'yield', 'to',
    'bool', 'str', 'int', 'float', 'list', 'dict', 'set', 'tuple',
    'type', 'object', 'id', 'hash', 'len', 'range', 'print', 'input',
    'open', 'file', 'bytes', 'bytearray', 'map', 'filter', 'zip',
    'enumerate', 'sorted', 'reversed', 'min', 'max', 'sum', 'abs',
    'all', 'any', 'next', 'iter', 'repr', 'format', 'vars', 'dir',
    'getattr', 'setattr', 'hasattr', 'delattr', 'callable', 'isinstance',
    'issubclass', 'super', 'property', 'staticmethod', 'classmethod'
] -%}
{%- macro field_name(field) -%}
{{ field.name }}{% if field.name in PYTHON_RESERVED or field.name == field.type_name %}_{% endif %}
{%- endmacro -%}

{# Macro for Python type from GraphQL type - uses direct types for scalars #}
{%- macro python_type(type_name) -%}
{%- if type_name == 'String' %}str
{%- elif type_name == 'Int' %}int
{%- elif type_name == 'Float' %}float
{%- elif type_name == 'Boolean' %}bool
{%- elif type_name == 'ID' %}str
{%- else %}{{ type_name }}
{%- endif %}
{%- endmacro -%}

{# Macro for field type annotation - ALL fields are Optional for automation #}
{%- macro field_type(field) -%}
Optional[{% if field.is_list %}List["{{ python_type(field.full_type_name) }}"]{% else %}"{{ python_type(field.full_type_name) }}"{% endif %}]
{%- endmacro -%}

{# Macro for field default value #}
{%- macro field_default(field) -%}
{% if field.is_list %}default_factory=list{% else %}None{% endif %}
{%- endmacro -%}

{# Generate interfaces first as base classes #}
{% for interface in interfaces %}
class {{ interface.name }}(BaseModel):
    """{{ (interface.description or interface.name)|safe_docstring }}"""
    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)
    {% for field in interface.fields %}
    {{ field_name(field) }}: {{ field_type(field) }} = Field({{ field_default(field) }}, description={{ (field.description or '')|repr }}, alias="{{ field.name }}")
    {% endfor %}

{% endfor %}

{# Generate types with interface inheritance #}
{% for type in types %}
{# Build inheritance list: interfaces first, then BaseModel as fallback #}
{%- set base_classes = type.full_interfaces if type.full_interfaces else ['BaseModel'] -%}
class {{ type.name }}({{ base_classes | join(', ') }}):
    """{{ (type.description or type.name)|safe_docstring }}"""
    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)
    {% for field in type.fields %}
    {# Skip fields inherited from interfaces #}
    {%- set inherited_fields = [] -%}
    {%- for iface_name in type.interfaces -%}
        {%- if iface_name in interface_fields -%}
            {%- for ifield in interface_fields[iface_name] -%}
                {%- set _ = inherited_fields.append(ifield) -%}
            {%- endfor -%}
        {%- endif -%}
    {%- endfor -%}
    {%- if field.name not in inherited_fields %}
    {{ field_name(field) }}: {{ field_type(field) }} = Field({{ field_default(field) }}, description={{ (field.description or '')|repr }}, alias="{{ field.name }}")
    {%- endif %}
    {% endfor %}

{% endfor %}

# Rebuild models to resolve forward references
# This is required for Pydantic v2 when models have circular dependencies
def _rebuild_models():
    """Rebuild all models in this module to resolve forward references."""
    import sys
    current_module = sys.modules[__name__]

    {%- if external_imports %}
    # Import all sibling modules to ensure types are available
    from . import (
        {%- for dep_file in external_imports.keys() %}
        {{ dep_file }},
        {%- endfor %}
    )
    {%- endif %}

    # Collect all model classes from this module
    model_classes = []
    for name in dir(current_module):
        obj = getattr(current_module, name)
        if isinstance(obj, type) and issubclass(obj, BaseModel) and obj is not BaseModel:
            model_classes.append(obj)

    # Rebuild each model class
    for cls in model_classes:
        try:
            cls.model_rebuild()
        except Exception:
            pass  # Silently ignore rebuild errors for already-built models

# Auto-rebuild on module import
_rebuild_models()

