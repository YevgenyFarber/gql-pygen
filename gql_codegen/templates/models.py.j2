"""Generated GraphQL models.

All fields are Optional for maximum flexibility in test automation.
The GraphQL API will validate required fields at runtime.

IMPORTANT: Call ensure_models_rebuilt() before using models with forward references.
"""

from __future__ import annotations
from typing import Optional, List, Any, Union, TYPE_CHECKING
from pydantic import BaseModel, Field, ConfigDict
from ..scalars import *
from ..enums import *

if TYPE_CHECKING:
{%- if external_imports %}
{%- for dep_file, dep_types in external_imports.items() %}
    from . import {{ dep_file }}
{%- endfor %}
{%- else %}
    pass
{%- endif %}


{# Macro for field name with reserved word handling #}
{%- macro field_name(field) -%}
{{ field.name }}{% if field.name in ['from', 'to', 'class', 'def', 'return', 'import', 'as', 'if', 'else', 'elif', 'for', 'while', 'try', 'except', 'finally', 'with', 'yield', 'lambda', 'not', 'and', 'or', 'is', 'in', 'global', 'nonlocal', 'assert', 'break', 'continue', 'pass', 'del', 'raise', 'None', 'True', 'False'] or field.name == field.type_name %}_{% endif %}
{%- endmacro -%}

{# Macro for Python type from GraphQL type - uses direct types for scalars #}
{%- macro python_type(type_name) -%}
{%- if type_name == 'String' %}str
{%- elif type_name == 'Int' %}int
{%- elif type_name == 'Float' %}float
{%- elif type_name == 'Boolean' %}bool
{%- elif type_name == 'ID' %}str
{%- else %}{{ type_name }}
{%- endif %}
{%- endmacro -%}

{# Macro for field type annotation - ALL fields are Optional for automation #}
{%- macro field_type(field) -%}
Optional[{% if field.is_list %}List["{{ python_type(field.full_type_name) }}"]{% else %}"{{ python_type(field.full_type_name) }}"{% endif %}]
{%- endmacro -%}

{# Macro for field default value #}
{%- macro field_default(field) -%}
{% if field.is_list %}default_factory=list{% else %}None{% endif %}
{%- endmacro -%}

{# Generate interfaces first as base classes #}
{% for interface in interfaces %}
class {{ interface.name }}(BaseModel):
    """{{ (interface.description or interface.name)|safe_docstring }}"""
    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)
    {% for field in interface.fields %}
    {{ field_name(field) }}: {{ field_type(field) }} = Field({{ field_default(field) }}, description={{ (field.description or '')|repr }}, alias="{{ field.name }}")
    {% endfor %}

{% endfor %}

{# Generate types with interface inheritance #}
{% for type in types %}
{# Build inheritance list: interfaces first, then BaseModel as fallback #}
{%- set base_classes = type.full_interfaces if type.full_interfaces else ['BaseModel'] -%}
class {{ type.name }}({{ base_classes | join(', ') }}):
    """{{ (type.description or type.name)|safe_docstring }}"""
    model_config = ConfigDict(arbitrary_types_allowed=True, populate_by_name=True)
    {% for field in type.fields %}
    {# Skip fields inherited from interfaces #}
    {%- set inherited_fields = [] -%}
    {%- for iface_name in type.interfaces -%}
        {%- if iface_name in interface_fields -%}
            {%- for ifield in interface_fields[iface_name] -%}
                {%- set _ = inherited_fields.append(ifield) -%}
            {%- endfor -%}
        {%- endif -%}
    {%- endfor -%}
    {%- if field.name not in inherited_fields %}
    {{ field_name(field) }}: {{ field_type(field) }} = Field({{ field_default(field) }}, description={{ (field.description or '')|repr }}, alias="{{ field.name }}")
    {%- endif %}
    {% endfor %}

{% endfor %}

